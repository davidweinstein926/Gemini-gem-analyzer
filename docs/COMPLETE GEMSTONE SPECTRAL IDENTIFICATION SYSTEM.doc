# COMPLETE GEMSTONE SPECTRAL IDENTIFICATION SYSTEM
# Developed for David's Gemstone Database Project
# Date: July 29, 2025

"""
PROJECT SUMMARY:
===============
This system analyzes spectral features of gemstones to distinguish Natural vs Synthetic stones.

KEY DISCOVERY: Natural sapphires have "pre-mound structures" (plateaus, small mounds) before 
the main mound, while synthetic sapphires have clean spectra with nothing before the main mound.

STONE ID FORMAT: [StoneNumber][LightSource][Orientation][ScanNumber]
- Stone Number: Client stones start with 'C', David's stones are numeric, Source light starts with 'S'  
- Light Source: B (Broadband), L (Laser), U (Ultraviolet)
- Orientation: C (Crown), P (Pavilion)
- Scan Number: 1, 2, 3, etc.
Examples: 58BC1, C0001LP2, S72925UC1

TOLERANCE RULES:
- Peaks: ±1 nm (very precise)
- Mounds/Plateaus: ±7 nm (broad features)

CURRENT DATABASE:
- 58BC1: Natural Orange Sapphire (has plateau before main mound)
- 60BP3: Synthetic Orange Sapphire (clean spectrum, no pre-mound features)

TEST RESULTS:
- Stone 92 (CUNKBC1/CUNKBP1): Natural orangish-brown sapphire
- Correctly identified as natural due to small mounds before main mound
"""

import sqlite3
import pandas as pd
import numpy as np
from datetime import datetime
import re
from typing import Dict, List, Tuple, Optional
import json

class GemstoneDatabase:
    def __init__(self, db_path: str = "gemstone_features.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize the database with proper tables and constraints"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create gemstone_features table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS gemstone_features (
            stone_id VARCHAR(20) PRIMARY KEY,
            stone_number VARCHAR(10) NOT NULL,
            light_source CHAR(1) NOT NULL CHECK (light_source IN ('B', 'L', 'U')),
            orientation CHAR(1) NOT NULL CHECK (orientation IN ('C', 'P')),
            scan_number INTEGER NOT NULL CHECK (scan_number > 0),
            stone_type VARCHAR(20),
            variety VARCHAR(50),
            date_analyzed DATE,
            analyst VARCHAR(20),
            spectrum_file VARCHAR(100),
            notes TEXT,
            ownership VARCHAR(20)
        )
        ''')
        
        # Create spectral_features table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS spectral_features (
            feature_id INTEGER PRIMARY KEY AUTOINCREMENT,
            stone_id VARCHAR(20) NOT NULL,
            feature_type VARCHAR(20) NOT NULL,
            start_wavelength DECIMAL(7,3) CHECK (start_wavelength BETWEEN 293.022 AND 1004.518),
            midpoint_wavelength DECIMAL(7,3) CHECK (midpoint_wavelength BETWEEN 293.022 AND 1004.518),
            end_wavelength DECIMAL(7,3) CHECK (end_wavelength BETWEEN 293.022 AND 1004.518),
            crest_wavelength DECIMAL(7,3) CHECK (crest_wavelength BETWEEN 293.022 AND 1004.518),
            max_wavelength DECIMAL(7,3) CHECK (max_wavelength BETWEEN 293.022 AND 1004.518),
            FOREIGN KEY (stone_id) REFERENCES gemstone_features (stone_id)
        )
        ''')
        
        conn.commit()
        conn.close()
        print("✅ Database initialized successfully")
    
    def parse_stone_id(self, stone_id: str) -> Tuple[str, str, str, int, str]:
        """Parse stone ID into components"""
        # Find position of light source (B, L, or U)
        light_pos = -1
        for i, char in enumerate(stone_id):
            if char in ['B', 'L', 'U']:
                light_pos = i
                break
        
        if light_pos == -1:
            raise ValueError(f"Invalid stone ID format: {stone_id}")
        
        stone_number = stone_id[:light_pos]
        light_source = stone_id[light_pos]
        orientation = stone_id[light_pos + 1]
        scan_number = int(stone_id[light_pos + 2:])
        
        # Determine ownership
        if stone_number.startswith('C'):
            ownership = 'Client'
        elif stone_number.startswith('S'):
            ownership = 'Source Light'
        else:
            ownership = 'David'
        
        return stone_number, light_source, orientation, scan_number, ownership
    
    def add_stone(self, stone_id: str, stone_type: str, variety: str, 
                  spectrum_file: str, notes: str = "", analyst: str = "David"):
        """Add a new stone to the database"""
        try:
            stone_number, light_source, orientation, scan_number, ownership = self.parse_stone_id(stone_id)
        except ValueError as e:
            print(f"❌ Error parsing stone ID: {e}")
            return False
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT INTO gemstone_features 
            (stone_id, stone_number, light_source, orientation, scan_number, 
             stone_type, variety, date_analyzed, analyst, spectrum_file, notes, ownership)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (stone_id, stone_number, light_source, orientation, scan_number,
                  stone_type, variety, datetime.now().date(), analyst, spectrum_file, notes, ownership))
            
            conn.commit()
            print(f"✅ Added stone {stone_id} to database")
            return True
        except sqlite3.IntegrityError as e:
            print(f"❌ Error adding stone {stone_id}: {e}")
            return False
        finally:
            conn.close()
    
    def add_feature(self, stone_id: str, feature_type: str, **wavelengths):
        """Add a spectral feature to a stone"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT INTO spectral_features 
            (stone_id, feature_type, start_wavelength, midpoint_wavelength, 
             end_wavelength, crest_wavelength, max_wavelength)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (stone_id, feature_type, 
                  wavelengths.get('start'), wavelengths.get('midpoint'),
                  wavelengths.get('end'), wavelengths.get('crest'), 
                  wavelengths.get('max')))
            
            conn.commit()
            print(f"✅ Added {feature_type} feature to {stone_id}")
            return True
        except Exception as e:
            print(f"❌ Error adding feature: {e}")
            return False
        finally:
            conn.close()
    
    def load_csv_data(self, csv_file_path: str, stone_type: str = None):
        """Load data from CSV files"""
        try:
            df = pd.read_csv(csv_file_path)
            
            # Extract stone info from first row
            first_row = df.iloc[0]
            stone_id = first_row['File'].replace('.txt', '')
            
            # Determine stone type if not provided
            if stone_type is None:
                stone_number = stone_id.split('B')[0] if 'B' in stone_id else stone_id.split('L')[0] if 'L' in stone_id else stone_id.split('U')[0]
                if stone_number == '58':
                    stone_type = 'Natural'
                elif stone_number == '60':
                    stone_type = 'Synthetic'
                else:
                    stone_type = 'Unknown'
            
            # Add stone to database
            success = self.add_stone(stone_id, stone_type, 'Orange Sapphire', first_row['File'])
            
            if success:
                # Add each feature
                for _, row in df.iterrows():
                    wavelengths = {}
                    for col in ['Start', 'Midpoint', 'End', 'Crest', 'Max']:
                        if col in row and pd.notna(row[col]):
                            wavelengths[col.lower()] = float(row[col])
                    
                    self.add_feature(stone_id, row['Feature'], **wavelengths)
            
            return True
        except Exception as e:
            print(f"❌ Error loading CSV {csv_file_path}: {e}")
            return False
    
    def get_stone_features(self, stone_id: str) -> List[Dict]:
        """Get all features for a specific stone"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT sf.*, gf.stone_type, gf.variety 
        FROM spectral_features sf
        JOIN gemstone_features gf ON sf.stone_id = gf.stone_id
        WHERE sf.stone_id = ?
        ''', (stone_id,))
        
        columns = [description[0] for description in cursor.description]
        results = []
        for row in cursor.fetchall():
            results.append(dict(zip(columns, row)))
        
        conn.close()
        return results
    
    def search_database(self, feature_type: str = None, stone_type: str = None) -> List[Dict]:
        """Search database for matching stones"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = '''
        SELECT gf.stone_id, gf.stone_type, gf.variety, gf.ownership,
               sf.feature_type, sf.start_wavelength, sf.midpoint_wavelength,
               sf.end_wavelength, sf.crest_wavelength, sf.max_wavelength
        FROM gemstone_features gf
        JOIN spectral_features sf ON gf.stone_id = sf.stone_id
        WHERE 1=1
        '''
        params = []
        
        if feature_type:
            query += " AND sf.feature_type = ?"
            params.append(feature_type)
        
        if stone_type:
            query += " AND gf.stone_type = ?"
            params.append(stone_type)
        
        cursor.execute(query, params)
        columns = [description[0] for description in cursor.description]
        results = []
        for row in cursor.fetchall():
            results.append(dict(zip(columns, row)))
        
        conn.close()
        return results
    
    def export_database_summary(self) -> Dict:
        """Export database contents for backup/transfer"""
        conn = sqlite3.connect(self.db_path)
        
        # Get all stones
        stones_df = pd.read_sql_query("SELECT * FROM gemstone_features", conn)
        features_df = pd.read_sql_query("SELECT * FROM spectral_features", conn)
        
        conn.close()
        
        return {
            'stones': stones_df.to_dict('records'),
            'features': features_df.to_dict('records'),
            'export_date': datetime.now().isoformat()
        }

class GemstoneMatchingEngine:
    def __init__(self, database: GemstoneDatabase):
        self.db = database
        self.peak_tolerance = 1.0  # ±1 nm for peaks
        self.broad_tolerance = 7.0  # ±7 nm for mounds/plateaus
    
    def calculate_feature_match(self, unknown_feature: Dict, db_feature: Dict) -> float:
        """Calculate match score between two features (0-100%)"""
        if unknown_feature['feature_type'] != db_feature['feature_type']:
            return 0.0
        
        feature_type = unknown_feature['feature_type']
        tolerance = self.peak_tolerance if feature_type == 'Peak' else self.broad_tolerance
        
        # Define which wavelength points to compare for each feature type
        points_to_compare = {
            'Peak': ['max_wavelength'],
            'Mound': ['start_wavelength', 'crest_wavelength', 'end_wavelength'],
            'Plateau': ['start_wavelength', 'midpoint_wavelength', 'end_wavelength'],
            'Valley': ['midpoint_wavelength'],
            'Trough': ['start_wavelength', 'end_wavelength']
        }
        
        points = points_to_compare.get(feature_type, [])
        if not points:
            return 0.0
        
        total_score = 0.0
        valid_comparisons = 0
        
        for point in points:
            unknown_val = unknown_feature.get(point)
            db_val = db_feature.get(point)
            
            if unknown_val is not None and db_val is not None:
                diff = abs(unknown_val - db_val)
                if diff <= tolerance:
                    # Score decreases linearly with distance
                    score = 100 * (1 - diff / tolerance)
                    total_score += score
                valid_comparisons += 1
        
        return total_score / valid_comparisons if valid_comparisons > 0 else 0.0
    
    def analyze_pre_mound_structure(self, features: List[Dict]) -> Dict:
        """
        KEY DISCOVERY: Analyze pre-mound structures to distinguish Natural vs Synthetic
        Natural stones have preliminary structures (plateau, small mound) before main mound
        Synthetic stones have clean spectra with nothing before main mound
        """
        # Find the main mound (largest wavelength range)
        mounds = [f for f in features if f['feature_type'] == 'Mound']
        plateaus = [f for f in features if f['feature_type'] == 'Plateau']
        
        if not mounds:
            return {'has_pre_structure': False, 'analysis': 'No mounds found'}
        
        # Find main mound (assume it's the one with largest wavelength span)
        main_mound = None
        max_span = 0
        
        for mound in mounds:
            if mound.get('start_wavelength') and mound.get('end_wavelength'):
                span = mound['end_wavelength'] - mound['start_wavelength']
                if span > max_span:
                    max_span = span
                    main_mound = mound
        
        if not main_mound:
            return {'has_pre_structure': False, 'analysis': 'No valid main mound found'}
        
        main_start = main_mound['start_wavelength']
        
        # Look for any features that end before the main mound starts
        pre_structures = []
        
        # Check other mounds
        for mound in mounds:
            if mound != main_mound and mound.get('end_wavelength'):
                if mound['end_wavelength'] < main_start:
                    pre_structures.append({
                        'type': 'Mound',
                        'range': f"{mound.get('start_wavelength', 'N/A')}-{mound['end_wavelength']}"
                    })
        
        # Check plateaus
        for plateau in plateaus:
            if plateau.get('end_wavelength'):
                if plateau['end_wavelength'] < main_start:
                    pre_structures.append({
                        'type': 'Plateau', 
                        'range': f"{plateau.get('start_wavelength', 'N/A')}-{plateau['end_wavelength']}"
                    })
        
        has_pre_structure = len(pre_structures) > 0
        
        return {
            'has_pre_structure': has_pre_structure,
            'pre_structures': pre_structures,
            'main_mound_start': main_start,
            'analysis': f"Found {len(pre_structures)} pre-mound structures" if has_pre_structure else "Clean spectrum, no pre-mound structures"
        }
    
    def match_unknown_to_database(self, unknown_features: List[Dict], use_pre_structure_analysis: bool = True) -> List[Dict]:
        """Match unknown stone features against database with enhanced analysis"""
        
        # Analyze pre-mound structure (KEY DISCOVERY)
        pre_structure_analysis = self.analyze_pre_mound_structure(unknown_features)
        
        # Get all stones in database
        all_stones = {}
        for stone_type in ['Natural', 'Synthetic']:
            stones = self.db.search_database(stone_type=stone_type)
            for stone_data in stones:
                stone_id = stone_data['stone_id']
                if stone_id not in all_stones:
                    all_stones[stone_id] = {
                        'stone_id': stone_id,
                        'stone_type': stone_data['stone_type'],
                        'variety': stone_data['variety'],
                        'features': []
                    }
                all_stones[stone_id]['features'].append(stone_data)
        
        results = []
        
        for stone_id, stone_data in all_stones.items():
            total_score = 0.0
            feature_matches = 0
            feature_details = []
            
            # Standard feature matching
            for unknown_feature in unknown_features:
                best_match_score = 0.0
                best_match_feature = None
                
                # Find best matching feature in this database stone
                for db_feature in stone_data['features']:
                    score = self.calculate_feature_match(unknown_feature, db_feature)
                    if score > best_match_score:
                        best_match_score = score
                        best_match_feature = db_feature
                
                if best_match_score > 0:
                    total_score += best_match_score
                    feature_matches += 1
                    feature_details.append({
                        'unknown_feature': unknown_feature['feature_type'],
                        'matched_feature': best_match_feature['feature_type'],
                        'score': best_match_score
                    })
            
            # Apply pre-structure bonus/penalty (KEY DISCOVERY IMPLEMENTATION)
            pre_structure_bonus = 0
            if use_pre_structure_analysis:
                if stone_data['stone_type'] == 'Natural' and pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = 20  # Bonus for natural with pre-structure
                elif stone_data['stone_type'] == 'Synthetic' and not pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = 20  # Bonus for synthetic without pre-structure
                elif stone_data['stone_type'] == 'Natural' and not pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = -10  # Penalty for natural without pre-structure
                elif stone_data['stone_type'] == 'Synthetic' and pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = -10  # Penalty for synthetic with pre-structure
            
            if feature_matches > 0:
                base_confidence = total_score / len(unknown_features)
                final_confidence = min(100, base_confidence + pre_structure_bonus)
                
                results.append({
                    'stone_id': stone_id,
                    'stone_type': stone_data['stone_type'],
                    'variety': stone_data['variety'],
                    'confidence': final_confidence,
                    'base_confidence': base_confidence,
                    'pre_structure_bonus': pre_structure_bonus,
                    'features_matched': feature_matches,
                    'total_features': len(unknown_features),
                    'match_details': feature_details,
                    'pre_structure_analysis': pre_structure_analysis
                })
        
        # Sort by confidence score (highest first)
        results.sort(key=lambda x: x['confidence'], reverse=True)
        return results

def load_csv_and_match(csv_file_path: str, db: GemstoneDatabase, matcher: GemstoneMatchingEngine):
    """Load a CSV file and match it against the database"""
    try:
        df = pd.read_csv(csv_file_path)
        
        # Convert CSV format to feature format
        unknown_features = []
        for _, row in df.iterrows():
            feature = {
                'feature_type': row['Feature'],
                'max_wavelength': row.get('Max') if pd.notna(row.get('Max')) else None,
                'start_wavelength': row.get('Start') if pd.notna(row.get('Start')) else None,
                'midpoint_wavelength': row.get('Midpoint') if pd.notna(row.get('Midpoint')) else None,
                'end_wavelength': row.get('End') if pd.notna(row.get('End')) else None,
                'crest_wavelength': row.get('Crest') if pd.notna(row.get('Crest')) else None
            }
            unknown_features.append(feature)
        
        # Run matching
        results = matcher.match_unknown_to_database(unknown_features)
        
        return results, unknown_features
        
    except Exception as e:
        print(f"Error loading and matching CSV: {e}")
        return None, None

def initialize_baseline_database():
    """Initialize database with baseline 58BC1 (Natural) and 60BP3 (Synthetic) data"""
    db = GemstoneDatabase()
    
    # Add 58BC1 (Natural Orange Sapphire) - HAS PRE-STRUCTURE (PLATEAU)
    db.add_stone('58BC1', 'Natural', 'Orange Sapphire', '58BC1.txt', 
                 notes="Natural orange sapphire with plateau before main mound")
    db.add_feature('58BC1', 'Peak', max=694.09)
    db.add_feature('58BC1', 'Mound', start=558.21, crest=670.59, end=874.22)
    db.add_feature('58BC1', 'Plateau', start=459.44, midpoint=515.28, end=557.74)
    
    # Add 60BP3 (Synthetic Orange Sapphire) - NO PRE-STRUCTURE
    db.add_stone('60BP3', 'Synthetic', 'Orange Sapphire', '60BP3.txt',
                 notes="Synthetic orange sapphire with clean spectrum, no pre-mound structures")
    db.add_feature('60BP3', 'Peak', max=694.10)
    db.add_feature('60BP3', 'Mound', start=500.87, crest=680.11, end=872.68)
    
    return db

def main_analysis_example():
    """Example of how to use the complete system"""
    
    # Initialize database with baseline data
    print("🔬 INITIALIZING GEMSTONE IDENTIFICATION SYSTEM")
    print("=" * 60)
    
    db = initialize_baseline_database()
    matcher = GemstoneMatchingEngine(db)
    
    print("✅ Database initialized with baseline stones:")
    print("   • 58BC1 (Natural) - has plateau before main mound")
    print("   • 60BP3 (Synthetic) - clean spectrum, no pre-structure")
    
    print("\n🎯 SYSTEM READY FOR UNKNOWN ANALYSIS")
    print("=" * 60)
    print("To analyze an unknown stone:")
    print("1. Use spectral marker program to create CSV")
    print("2. Load CSV: results, features = load_csv_and_match('unknown.csv', db, matcher)")
    print("3. Review results for identification")
    
    print("\n🔑 KEY DISCOVERY:")
    print("Natural sapphires have pre-mound structures (plateau/small mound)")
    print("Synthetic sapphires have clean spectra with no pre-mound features")
    
    return db, matcher

# REFERENCE DATA FOR QUICK RESTART
BASELINE_DATA = {
    "project_summary": """
    Gemstone Spectral Identification System
    Key Discovery: Natural vs Synthetic distinction via pre-mound structures
    Natural stones: Have plateau/small mound before main mound  
    Synthetic stones: Clean spectrum, nothing before main mound
    
    Test Results: Stone 92 (CUNKBC1/CUNKBP1) correctly identified as Natural
    due to presence of small mounds before main mound structure.
    """,
    
    "database_stones": {
        "58BC1": {
            "type": "Natural",
            "features": ["Peak: 694.09nm", "Mound: 558-874nm", "Plateau: 459-558nm"],
            "note": "Has plateau before main mound"
        },
        "60BP3": {
            "type": "Synthetic", 
            "features": ["Peak: 694.10nm", "Mound: 501-873nm"],
            "note": "Clean spectrum, no pre-structure"
        }
    },
    
    "tolerances": {
        "peaks": "±1 nm",
        "mounds_plateaus": "±7 nm"
    },
    
    "stone_id_format": "[StoneNumber][B/L/U][C/P][ScanNumber]",
    
    "next_steps": [
        "Test more synthetic stones to confirm clean pre-mound pattern",
        "Analyze Stone 92 with UV and Laser light",
        "Expand database to 500+ stones",
        "Implement pre-structure analysis in matching algorithm"
    ]
}

if __name__ == "__main__":
    # Save reference data
    with open('gemstone_project_summary.json', 'w') as f:
        json.dump(BASELINE_DATA, f, indent=2)
    
    # Initialize system
    db, matcher = main_analysis_example()
    
    print(f"\n💾 System package created successfully!")
    print(f"📁 Files created:")
    print(f"   • gemstone_features.db (SQLite database)")
    print(f"   • gemstone_project_summary.json (Project summary)")
    print(f"   • This complete Python system file")