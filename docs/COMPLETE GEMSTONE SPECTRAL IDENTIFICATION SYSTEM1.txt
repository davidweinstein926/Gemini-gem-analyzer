# COMPLETE GEMSTONE SPECTRAL IDENTIFICATION SYSTEM
# Developed for David's Gemstone Database Project
# Date: July 29, 2025

"""
PROJECT SUMMARY:
===============
This system analyzes spectral features of gemstones to distinguish Natural vs Synthetic stones.

KEY DISCOVERY: Natural sapphires have "pre-mound structures" (plateaus, small mounds) before 
the main mound, while synthetic sapphires have clean spectra with nothing before the main mound.

STONE ID FORMAT: [StoneNumber][LightSource][Orientation][ScanNumber]
- Stone Number: Client stones start with 'C', David's stones are numeric, Source light starts with 'S'  
- Light Source: B (Broadband), L (Laser), U (Ultraviolet)
- Orientation: C (Crown), P (Pavilion)
- Scan Number: 1, 2, 3, etc.
Examples: 58BC1, C0001LP2, S72925UC1

TOLERANCE RULES:
- Peaks: Â±1 nm (very precise)
- Mounds/Plateaus: Â±7 nm (broad features)

CURRENT DATABASE:
- 58BC1: Natural Orange Sapphire (has plateau before main mound)
- 60BP3: Synthetic Orange Sapphire (clean spectrum, no pre-mound features)

TEST RESULTS:
- Stone 92 (CUNKBC1/CUNKBP1): Natural orangish-brown sapphire
- Correctly identified as natural due to small mounds before main mound
"""

import sqlite3
import pandas as pd
import numpy as np
from datetime import datetime
import re
from typing import Dict, List, Tuple, Optional
import json
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog

class GemstoneDatabase:
    def __init__(self, db_path: str = "gemstone_features.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """Initialize the database with proper tables and constraints"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create gemstone_features table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS gemstone_features (
            stone_id VARCHAR(20) PRIMARY KEY,
            stone_number VARCHAR(10) NOT NULL,
            light_source CHAR(1) NOT NULL CHECK (light_source IN ('B', 'L', 'U')),
            orientation CHAR(1) NOT NULL CHECK (orientation IN ('C', 'P')),
            scan_number INTEGER NOT NULL CHECK (scan_number > 0),
            stone_type VARCHAR(20),
            variety VARCHAR(50),
            date_analyzed DATE,
            analyst VARCHAR(20),
            spectrum_file VARCHAR(100),
            notes TEXT,
            ownership VARCHAR(20)
        )
        ''')
        
        # Create spectral_features table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS spectral_features (
            feature_id INTEGER PRIMARY KEY AUTOINCREMENT,
            stone_id VARCHAR(20) NOT NULL,
            feature_type VARCHAR(20) NOT NULL,
            start_wavelength DECIMAL(7,3) CHECK (start_wavelength BETWEEN 293.022 AND 1004.518),
            midpoint_wavelength DECIMAL(7,3) CHECK (midpoint_wavelength BETWEEN 293.022 AND 1004.518),
            end_wavelength DECIMAL(7,3) CHECK (end_wavelength BETWEEN 293.022 AND 1004.518),
            crest_wavelength DECIMAL(7,3) CHECK (crest_wavelength BETWEEN 293.022 AND 1004.518),
            max_wavelength DECIMAL(7,3) CHECK (max_wavelength BETWEEN 293.022 AND 1004.518),
            bottom_wavelength DECIMAL(7,3) CHECK (bottom_wavelength BETWEEN 293.022 AND 1004.518),
            symmetry_ratio DECIMAL(6,3),
            skew_description VARCHAR(50),
            FOREIGN KEY (stone_id) REFERENCES gemstone_features (stone_id)
        )
        ''')
        
        conn.commit()
        conn.close()
        print("âœ… Database initialized successfully")
    
    def parse_stone_id(self, stone_id: str) -> Tuple[str, str, str, int, str]:
        """Parse stone ID into components"""
        # Find position of light source (B, L, or U)
        light_pos = -1
        for i, char in enumerate(stone_id):
            if char in ['B', 'L', 'U']:
                light_pos = i
                break
        
        if light_pos == -1:
            raise ValueError(f"Invalid stone ID format: {stone_id}")
        
        stone_number = stone_id[:light_pos]
        light_source = stone_id[light_pos]
        orientation = stone_id[light_pos + 1]
        scan_number = int(stone_id[light_pos + 2:])
        
        # Determine ownership
        if stone_number.startswith('C'):
            ownership = 'Client'
        elif stone_number.startswith('S'):
            ownership = 'Source Light'
        else:
            ownership = 'David'
        
        return stone_number, light_source, orientation, scan_number, ownership
    
    def add_stone(self, stone_id: str, stone_type: str, variety: str, 
                  spectrum_file: str, notes: str = "", analyst: str = "David"):
        """Add a new stone to the database"""
        try:
            stone_number, light_source, orientation, scan_number, ownership = self.parse_stone_id(stone_id)
        except ValueError as e:
            print(f"âŒ Error parsing stone ID: {e}")
            return False
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT INTO gemstone_features 
            (stone_id, stone_number, light_source, orientation, scan_number, 
             stone_type, variety, date_analyzed, analyst, spectrum_file, notes, ownership)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (stone_id, stone_number, light_source, orientation, scan_number,
                  stone_type, variety, datetime.now().date(), analyst, spectrum_file, notes, ownership))
            
            conn.commit()
            print(f"âœ… Added stone {stone_id} to database")
            return True
        except sqlite3.IntegrityError as e:
            print(f"âŒ Error adding stone {stone_id}: {e}")
            return False
        finally:
            conn.close()
    
    def add_feature(self, stone_id: str, feature_type: str, **wavelengths):
        """Add a spectral feature to a stone"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
            INSERT INTO spectral_features 
            (stone_id, feature_type, start_wavelength, midpoint_wavelength, 
             end_wavelength, crest_wavelength, max_wavelength, bottom_wavelength,
             symmetry_ratio, skew_description)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (stone_id, feature_type, 
                  wavelengths.get('start'), wavelengths.get('midpoint'),
                  wavelengths.get('end'), wavelengths.get('crest'), 
                  wavelengths.get('max'), wavelengths.get('bottom'),
                  wavelengths.get('symmetry_ratio'), wavelengths.get('skew_description')))
            
            conn.commit()
            print(f"âœ… Added {feature_type} feature to {stone_id}")
            return True
        except Exception as e:
            print(f"âŒ Error adding feature: {e}")
            return False
        finally:
            conn.close()
    
    def load_csv_data(self, csv_file_path: str, stone_type: str = None):
        """Load data from CSV files"""
        try:
            df = pd.read_csv(csv_file_path)
            
            # Extract stone info from first row
            first_row = df.iloc[0]
            stone_id = first_row['File'].replace('.txt', '')
            
            # Determine stone type if not provided
            if stone_type is None:
                stone_number = stone_id.split('B')[0] if 'B' in stone_id else stone_id.split('L')[0] if 'L' in stone_id else stone_id.split('U')[0]
                if stone_number == '58':
                    stone_type = 'Natural'
                elif stone_number == '60':
                    stone_type = 'Synthetic'
                else:
                    stone_type = 'Unknown'
            
            # Add stone to database
            success = self.add_stone(stone_id, stone_type, 'Orange Sapphire', first_row['File'])
            
            if success:
                # Add each feature
                for _, row in df.iterrows():
                    wavelengths = {}
                    for col in ['Start', 'Midpoint', 'End', 'Crest', 'Max', 'Bottom']:
                        if col in row and pd.notna(row[col]):
                            wavelengths[col.lower()] = float(row[col])
                    
                    # Add symmetry data if available
                    if 'Symmetry_Ratio' in row and pd.notna(row['Symmetry_Ratio']):
                        wavelengths['symmetry_ratio'] = float(row['Symmetry_Ratio'])
                    if 'Skew_Description' in row and pd.notna(row['Skew_Description']):
                        wavelengths['skew_description'] = str(row['Skew_Description'])
                    
                    self.add_feature(stone_id, row['Feature'], **wavelengths)
            
            return True
        except Exception as e:
            print(f"âŒ Error loading CSV {csv_file_path}: {e}")
            return False
    
    def get_stone_features(self, stone_id: str) -> List[Dict]:
        """Get all features for a specific stone"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT sf.*, gf.stone_type, gf.variety 
        FROM spectral_features sf
        JOIN gemstone_features gf ON sf.stone_id = gf.stone_id
        WHERE sf.stone_id = ?
        ''', (stone_id,))
        
        columns = [description[0] for description in cursor.description]
        results = []
        for row in cursor.fetchall():
            results.append(dict(zip(columns, row)))
        
        conn.close()
        return results
    
    def search_database(self, feature_type: str = None, stone_type: str = None) -> List[Dict]:
        """Search database for matching stones"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = '''
        SELECT gf.stone_id, gf.stone_type, gf.variety, gf.ownership,
               sf.feature_type, sf.start_wavelength, sf.midpoint_wavelength,
               sf.end_wavelength, sf.crest_wavelength, sf.max_wavelength, sf.bottom_wavelength,
               sf.symmetry_ratio, sf.skew_description
        FROM gemstone_features gf
        JOIN spectral_features sf ON gf.stone_id = sf.stone_id
        WHERE 1=1
        '''
        params = []
        
        if feature_type:
            query += " AND sf.feature_type = ?"
            params.append(feature_type)
        
        if stone_type:
            query += " AND gf.stone_type = ?"
            params.append(stone_type)
        
        cursor.execute(query, params)
        columns = [description[0] for description in cursor.description]
        results = []
        for row in cursor.fetchall():
            results.append(dict(zip(columns, row)))
        
        conn.close()
        return results
    
    def export_database_summary(self) -> Dict:
        """Export database contents for backup/transfer"""
        conn = sqlite3.connect(self.db_path)
        
        # Get all stones
        stones_df = pd.read_sql_query("SELECT * FROM gemstone_features", conn)
        features_df = pd.read_sql_query("SELECT * FROM spectral_features", conn)
        
        conn.close()
        
        return {
            'stones': stones_df.to_dict('records'),
            'features': features_df.to_dict('records'),
            'export_date': datetime.now().isoformat()
        }

class GemstoneMatchingEngine:
    def __init__(self, database: GemstoneDatabase):
        self.db = database
        self.peak_tolerance = 1.0  # Â±1 nm for peaks
        self.broad_tolerance = 7.0  # Â±7 nm for mounds/plateaus
    
    def calculate_feature_match(self, unknown_feature: Dict, db_feature: Dict) -> float:
        """Calculate match score between two features (0-100%)"""
        if unknown_feature['feature_type'] != db_feature['feature_type']:
            return 0.0
        
        feature_type = unknown_feature['feature_type']
        tolerance = self.peak_tolerance if feature_type == 'Peak' else self.broad_tolerance
        
        # Define which wavelength points to compare for each feature type
        points_to_compare = {
            'Peak': ['max_wavelength'],
            'Mound': ['start_wavelength', 'crest_wavelength', 'end_wavelength'],
            'Plateau': ['start_wavelength', 'midpoint_wavelength', 'end_wavelength'],
            'Valley': ['midpoint_wavelength'],
            'Trough': ['start_wavelength', 'bottom_wavelength', 'end_wavelength']
        }
        
        points = points_to_compare.get(feature_type, [])
        if not points:
            return 0.0
        
        total_score = 0.0
        valid_comparisons = 0
        
        for point in points:
            unknown_val = unknown_feature.get(point)
            db_val = db_feature.get(point)
            
            if unknown_val is not None and db_val is not None:
                diff = abs(unknown_val - db_val)
                if diff <= tolerance:
                    # Score decreases linearly with distance
                    score = 100 * (1 - diff / tolerance)
                    total_score += score
                valid_comparisons += 1
        
        return total_score / valid_comparisons if valid_comparisons > 0 else 0.0
    
    def analyze_pre_mound_structure(self, features: List[Dict]) -> Dict:
        """
        KEY DISCOVERY: Analyze pre-mound structures to distinguish Natural vs Synthetic
        Natural stones have preliminary structures (plateau, small mound) before main mound
        Synthetic stones have clean spectra with nothing before main mound
        """
        # Find the main mound (largest wavelength range)
        mounds = [f for f in features if f['feature_type'] == 'Mound']
        plateaus = [f for f in features if f['feature_type'] == 'Plateau']
        
        if not mounds:
            return {'has_pre_structure': False, 'analysis': 'No mounds found'}
        
        # Find main mound (assume it's the one with largest wavelength span)
        main_mound = None
        max_span = 0
        
        for mound in mounds:
            if mound.get('start_wavelength') and mound.get('end_wavelength'):
                span = mound['end_wavelength'] - mound['start_wavelength']
                if span > max_span:
                    max_span = span
                    main_mound = mound
        
        if not main_mound:
            return {'has_pre_structure': False, 'analysis': 'No valid main mound found'}
        
        main_start = main_mound['start_wavelength']
        
        # Look for any features that end before the main mound starts
        pre_structures = []
        
        # Check other mounds
        for mound in mounds:
            if mound != main_mound and mound.get('end_wavelength'):
                if mound['end_wavelength'] < main_start:
                    pre_structures.append({
                        'type': 'Mound',
                        'range': f"{mound.get('start_wavelength', 'N/A')}-{mound['end_wavelength']}"
                    })
        
        # Check plateaus
        for plateau in plateaus:
            if plateau.get('end_wavelength'):
                if plateau['end_wavelength'] < main_start:
                    pre_structures.append({
                        'type': 'Plateau', 
                        'range': f"{plateau.get('start_wavelength', 'N/A')}-{plateau['end_wavelength']}"
                    })
        
        has_pre_structure = len(pre_structures) > 0
        
        return {
            'has_pre_structure': has_pre_structure,
            'pre_structures': pre_structures,
            'main_mound_start': main_start,
            'analysis': f"Found {len(pre_structures)} pre-mound structures" if has_pre_structure else "Clean spectrum, no pre-mound structures"
        }
    
    def match_unknown_to_database(self, unknown_features: List[Dict], use_pre_structure_analysis: bool = True) -> List[Dict]:
        """Match unknown stone features against database with enhanced analysis"""
        
        # Analyze pre-mound structure (KEY DISCOVERY)
        pre_structure_analysis = self.analyze_pre_mound_structure(unknown_features)
        
        # Get all stones in database
        all_stones = {}
        for stone_type in ['Natural', 'Synthetic']:
            stones = self.db.search_database(stone_type=stone_type)
            for stone_data in stones:
                stone_id = stone_data['stone_id']
                if stone_id not in all_stones:
                    all_stones[stone_id] = {
                        'stone_id': stone_id,
                        'stone_type': stone_data['stone_type'],
                        'variety': stone_data['variety'],
                        'features': []
                    }
                all_stones[stone_id]['features'].append(stone_data)
        
        results = []
        
        for stone_id, stone_data in all_stones.items():
            total_score = 0.0
            feature_matches = 0
            feature_details = []
            
            # Standard feature matching
            for unknown_feature in unknown_features:
                best_match_score = 0.0
                best_match_feature = None
                
                # Find best matching feature in this database stone
                for db_feature in stone_data['features']:
                    score = self.calculate_feature_match(unknown_feature, db_feature)
                    if score > best_match_score:
                        best_match_score = score
                        best_match_feature = db_feature
                
                if best_match_score > 0:
                    total_score += best_match_score
                    feature_matches += 1
                    feature_details.append({
                        'unknown_feature': unknown_feature['feature_type'],
                        'matched_feature': best_match_feature['feature_type'],
                        'score': best_match_score
                    })
            
            # Apply pre-structure bonus/penalty (KEY DISCOVERY IMPLEMENTATION)
            pre_structure_bonus = 0
            if use_pre_structure_analysis:
                if stone_data['stone_type'] == 'Natural' and pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = 20  # Bonus for natural with pre-structure
                elif stone_data['stone_type'] == 'Synthetic' and not pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = 20  # Bonus for synthetic without pre-structure
                elif stone_data['stone_type'] == 'Natural' and not pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = -10  # Penalty for natural without pre-structure
                elif stone_data['stone_type'] == 'Synthetic' and pre_structure_analysis['has_pre_structure']:
                    pre_structure_bonus = -10  # Penalty for synthetic with pre-structure
            
            if feature_matches > 0:
                base_confidence = total_score / len(unknown_features)
                final_confidence = min(100, base_confidence + pre_structure_bonus)
                
                results.append({
                    'stone_id': stone_id,
                    'stone_type': stone_data['stone_type'],
                    'variety': stone_data['variety'],
                    'confidence': final_confidence,
                    'base_confidence': base_confidence,
                    'pre_structure_bonus': pre_structure_bonus,
                    'features_matched': feature_matches,
                    'total_features': len(unknown_features),
                    'match_details': feature_details,
                    'pre_structure_analysis': pre_structure_analysis
                })
        
        # Sort by confidence score (highest first)
        results.sort(key=lambda x: x['confidence'], reverse=True)
        return results

def load_csv_and_match(csv_file_path: str, db: GemstoneDatabase, matcher: GemstoneMatchingEngine):
    """Load a CSV file and match it against the database"""
    try:
        df = pd.read_csv(csv_file_path)
        
        # Convert CSV format to feature format
        unknown_features = []
        for _, row in df.iterrows():
            feature = {
                'feature_type': row['Feature'],
                'max_wavelength': row.get('Max') if pd.notna(row.get('Max')) else None,
                'start_wavelength': row.get('Start') if pd.notna(row.get('Start')) else None,
                'midpoint_wavelength': row.get('Midpoint') if pd.notna(row.get('Midpoint')) else None,
                'end_wavelength': row.get('End') if pd.notna(row.get('End')) else None,
                'crest_wavelength': row.get('Crest') if pd.notna(row.get('Crest')) else None,
                'bottom_wavelength': row.get('Bottom') if pd.notna(row.get('Bottom')) else None
            }
            unknown_features.append(feature)
        
        # Run matching
        results = matcher.match_unknown_to_database(unknown_features)
        
        return results, unknown_features
        
    except Exception as e:
        print(f"Error loading and matching CSV: {e}")
        return None, None

def initialize_baseline_database():
    """Initialize database with baseline 58BC1 (Natural) and 60BP3 (Synthetic) data"""
    db = GemstoneDatabase()
    
    # Add 58BC1 (Natural Orange Sapphire) - HAS PRE-STRUCTURE (PLATEAU)
    db.add_stone('58BC1', 'Natural', 'Orange Sapphire', '58BC1.txt', 
                 notes="Natural orange sapphire with plateau before main mound")
    db.add_feature('58BC1', 'Peak', max=694.09)
    db.add_feature('58BC1', 'Mound', start=558.21, crest=670.59, end=874.22)
    db.add_feature('58BC1', 'Plateau', start=459.44, midpoint=515.28, end=557.74)
    
    # Add 60BP3 (Synthetic Orange Sapphire) - NO PRE-STRUCTURE
    db.add_stone('60BP3', 'Synthetic', 'Orange Sapphire', '60BP3.txt',
                 notes="Synthetic orange sapphire with clean spectrum, no pre-mound structures")
    db.add_feature('60BP3', 'Peak', max=694.10)
    db.add_feature('60BP3', 'Mound', start=500.87, crest=680.11, end=872.68)
    
    return db

class GemstoneCSVImporter:
    """Import CSV files from structural marker into database"""
    
    def __init__(self, database: GemstoneDatabase):
        self.db = database
    
    def import_csv_files(self):
        """Import multiple CSV files with duplicate checking"""
        print("ðŸ”¬ GEMSTONE CSV IMPORTER")
        print("=" * 40)
        
        try:
            root = tk.Tk()
            root.withdraw()
            root.lift()
            root.attributes('-topmost', True)
            
            csv_files = filedialog.askopenfilenames(
                title="Select Structural Marker CSV Files",
                filetypes=[("CSV files", "*.csv")],
                parent=root
            )
            
            root.quit()
            root.destroy()
            
            if not csv_files:
                print("âŒ No files selected")
                return
            
            success_count = 0
            
            for csv_file in csv_files:
                print(f"\nðŸ“ Processing: {os.path.basename(csv_file)}")
                
                # Check if already exists
                stone_id = self.extract_stone_id_from_csv(csv_file)
                if stone_id and self.stone_exists(stone_id):
                    choice = self.handle_duplicate(stone_id, csv_file)
                    if choice == "skip":
                        continue
                    elif choice == "rename":
                        stone_id = self.get_new_name(stone_id)
                        if not stone_id:
                            continue
                
                # Get classification
                stone_type, variety = self.get_classification(stone_id)
                
                # Import
                if self.db.load_csv_data(csv_file, stone_type):
                    success_count += 1
                    print(f"âœ… Imported {stone_id}")
            
            print(f"\nðŸ“Š Imported {success_count} files successfully")
            
        except Exception as e:
            print(f"âŒ Import error: {e}")
    
    def extract_stone_id_from_csv(self, csv_file):
        """Extract stone ID from CSV filename"""
        try:
            basename = os.path.basename(csv_file)
            # Remove _features_timestamp.csv pattern
            stone_id = re.sub(r'_features_\d{8}_\d{6}\.csv, '', basename)
            return stone_id
        except:
            return None
    
    def stone_exists(self, stone_id):
        """Check if stone exists in database"""
        features = self.db.get_stone_features(stone_id)
        return len(features) > 0
    
    def handle_duplicate(self, stone_id, csv_file):
        """Handle duplicate stone"""
        try:
            root = tk.Tk()
            root.withdraw()
            
            choice = messagebox.askyesnocancel(
                "Duplicate Stone",
                f"Stone {stone_id} already exists!\n\nYES = Override\nNO = Rename\nCANCEL = Skip",
                parent=root
            )
            
            root.destroy()
            
            if choice is True:
                return "override"
            elif choice is False:
                return "rename"
            else:
                return "skip"
        except:
            return "skip"
    
    def get_new_name(self, original_id):
        """Get new stone name"""
        try:
            root = tk.Tk()
            root.withdraw()
            
            new_name = simpledialog.askstring(
                "New Stone ID",
                f"Enter new ID for {original_id}:",
                parent=root
            )
            
            root.destroy()
            return new_name.strip() if new_name else None
        except:
            return None
    
    def get_classification(self, stone_id):
        """Get stone classification"""
        try:
            root = tk.Tk()
            root.withdraw()
            
            # Natural vs Synthetic
            is_natural = messagebox.askyesno(
                "Stone Type",
                f"Is {stone_id} a NATURAL stone?",
                parent=root
            )
            
            stone_type = "Natural" if is_natural else "Synthetic"
            
            # Variety
            variety = simpledialog.askstring(
                "Stone Variety",
                f"Enter variety for {stone_id}:",
                initialvalue="Sapphire",
                parent=root
            )
            
            root.destroy()
            
            return stone_type, variety or "Unknown"
        except:
            return "Unknown", "Unknown"

def main_analysis_example():
    """Example of how to use the complete system"""
    
    print("ðŸ”¬ INITIALIZING GEMSTONE IDENTIFICATION SYSTEM")
    print("=" * 60)
    
    db = initialize_baseline_database()
    matcher = GemstoneMatchingEngine(db)
    importer = GemstoneCSVImporter(db)
    
    print("âœ… Database initialized with baseline stones:")
    print("   â€¢ 58BC1 (Natural) - has plateau before main mound")
    print("   â€¢ 60BP3 (Synthetic) - clean spectrum, no pre-structure")
    
    print("\nðŸŽ¯ AVAILABLE FUNCTIONS:")
    print("=" * 60)
    print("1. importer.import_csv_files() - Import structural marker CSV files")
    print("2. load_csv_and_match('file.csv', db, matcher) - Match unknown stone")
    print("3. db.search_database(stone_type='Natural') - Search database")
    print("4. db.export_database_summary() - Export all data")
    
    print("\nðŸ”‘ KEY DISCOVERY:")
    print("Natural sapphires have pre-mound structures (plateau/small mound)")
    print("Synthetic sapphires have clean spectra with no pre-mound features")
    
    return db, matcher, importer

if __name__ == "__main__":
    # Initialize the complete system
    db, matcher, importer = main_analysis_example()
    
    # Example: Import CSV files
    print("\nðŸ”„ To import your CSV files, run:")
    print("importer.import_csv_files()")
    
    # Example: Match an unknown stone
    print("\nðŸ”„ To match an unknown stone, run:")
    print("results, features = load_csv_and_match('unknown.csv', db, matcher)")
    print("print(results[0])  # Show best match")