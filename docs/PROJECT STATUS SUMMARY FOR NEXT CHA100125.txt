PROJECT STATUS SUMMARY FOR NEXT CHAT
WHAT WE HAVE WORKING
Database (gemini_structural.db):

1,044 records from 76 CSV files across 15 gems
Correct light source classification (Halogen/Laser/UV)
Preserves exact CSV data including negative intensities
File-level duplicate prevention
Timestamp-aware structure with analysis_date column

Database Importer (perfect_import_v2.py):

Prevents duplicate file imports
Preserves exact CSV data (no auto-fixing)
Correct light source detection via regex pattern matching
Backs up before rebuilding
Archives imported files

Data Structure:

Halogen/Laser: Feature-based (Start, End, Crest, Summary) with Symmetry_Ratio, Skew_Description, Width_nm
UV: Peak-based with Wavelength_nm, Intensity, Prominence
All have Wavelength and Intensity columns

THE CORE PROBLEM
Current analyzer (multi_gem_structural_analyzer.py) is fundamentally incompatible with your data:

Treats all data as simple wavelength/intensity curves - ignores feature types
Uses ±10nm tolerance - way too loose (should be ±0.5nm for peaks, ±1nm for mounds)
No feature-type matching - compares Peak to Trough, Mound to Summary randomly
Includes Summary/Baseline rows - arbitrary reference data pollutes comparison
No UV 811nm normalization - should compare intensity ratios, not absolute values
Self-match detection fails - even identical data scores poorly (gem 197 = 34.8% vs itself)

WHAT THE OLD SYSTEM DID RIGHT
From structural_match_finder.py and config/settings:
python# Type-based features with weights
T (Trough): weight 5
P (Peak): weight 4  
V (Valley): weight 3
C (Crest): weight 2
S (Start/Shoulder): weight 1

# Type-specific tolerances
peak_tolerance: 0.5 nm
mound_tolerance: 1.0 nm
plateau_tolerance: 2.0 nm
wavelength_tolerance: 2.0 nm (overall)
intensity_tolerance: 10% (relative)

# UV normalization
Normalize all UV intensities to 811nm peak

# Penalty scoring (lower = better)
missing_feature_penalty: 5
extra_feature_penalty: 20
Score = sum of weighted penalties
Matching Algorithm:

Extract features as Type_Wavelength tags (e.g., "P_431.2", "C_450.0")
Match only same-type features (Peak to Peak, Mound to Mound)
Apply type-specific wavelength tolerance
Check intensity within ±10%
Count mismatches (missing + extra features)
Calculate score = weighted sum of penalties

REQUIRED SOLUTION
New feature-aware analyzer that:

Maps your Point_Type to feature types:

Start → S (Shoulder)
Crest → C (Crest)
End → End of feature
Peak → P (Peak)
Summary → EXCLUDE from comparison


Feature extraction per light source:

Halogen/Laser: Group by Feature column, extract Start/Crest/End wavelengths, compare feature-by-feature
UV: Use Peak_Number, normalize intensities to 811nm reference


Type-specific tolerances:

Peak positions: ±1nm
Mound Start/End: ±5nm
Crest positions: ±1nm
Intensity: ±10% relative


Scoring logic:

Match features by type only
Apply appropriate tolerance for that feature type
Penalty for missing/extra features
Lower score = better match


UV special handling:

Normalize all intensities to 811nm peak = 100
Compare intensity ratios, not absolute values
Peak wavelengths are consistent, so matching is straightforward


Combined scoring:

Individual light source scores
Only combine database gems with same-date B+L+U
Weighted combination (B=40%, L=35%, U=25% from config)



PROGRAMS TO POST IN NEXT CHAT
Essential for understanding:

https://raw.githubusercontent.com/davidweinstein926/Gemini-gem-analyzer/refs/heads/main/src/structural_analysis/multi_gem_structural_analyzer.py (current broken analyzer)
https://raw.githubusercontent.com/davidweinstein926/Gemini-gem-analyzer/refs/heads/main/src/structural_analysis/structural_match_finder.py (old working logic)
https://raw.githubusercontent.com/davidweinstein926/Gemini-gem-analyzer/refs/heads/main/src/structural_analysis/config/settings (tolerances and penalties)
https://raw.githubusercontent.com/davidweinstein926/Gemini-gem-analyzer/refs/heads/main/database/perfect_structural_archive_importer.py (reference importer)

Database management:
5. Perfect_import_v2.py (from this session's artifact - the working importer)
Sample data files to share:
6. 197BC3_halogen_structural_20250925_210557.csv (example halogen structure)
7. 197LC3_laser_structural_20250925_210900.csv (example laser structure)
8. 197UC2_uv_structural_auto_20250925_212823.csv (example UV structure)
IMPLEMENTATION PLAN
Phase 1: Feature extraction functions

Parse Halogen/Laser by Feature column (Mound_1, Peak_1, etc.)
Parse UV by Peak_Number
Filter out Summary/Baseline rows

Phase 2: Type-specific matching

Mound-to-Mound comparison (Start, Crest, End wavelengths)
Peak-to-Peak comparison (wavelength + intensity)
Apply appropriate tolerances

Phase 3: UV normalization

Find 811nm peak in both GOI and database
Normalize all intensities to that reference
Compare ratios

Phase 4: Scoring

Implement penalty-based scoring
Handle missing/extra features
Weight by feature importance

Phase 5: Integration

Replace compute_similarity() in multi_gem_structural_analyzer.py
Keep timestamp-aware combining logic
Keep database validation logic

KEY INSIGHT FROM THIS SESSION
Your database contains rich feature-based structural data, but the analyzer is treating it like simple spectral curves. The solution isn't fixing tolerances or thresholds - it's implementing feature-aware comparison that understands Mounds, Peaks, Crests are distinct structural elements that must be matched type-to-type.
The old structural_match_finder.py had this logic working perfectly. We need to adapt that feature-based approach to work with your new database schema and timestamp-aware validation system.RetryClaude can make mistakes. Please double-check responses.Research Sonnet 4.5