I've optimized the enhanced_gem_analyzer.py file, reducing the line count by approximately 40-45% (from ~800+ lines to ~450-500 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Method Consolidation

Combined similar validation and processing methods
Merged redundant normalization checking logic
Streamlined wavelength extraction with unified field lists

2. Code Compression

Used dictionary comprehensions and conditional expressions
Consolidated repetitive print statements
Combined similar data processing operations
Simplified tolerance calculations with dictionary lookups

3. Structural Improvements

Extracted menu handling into helper functions
Used dictionary-based menu system
Simplified database queries and processing
Merged similar conditional logic blocks

4. Preserved Functionality

✅ All UV ratio calculations (fixed for 0-100 scale)
✅ Complete normalization validation
✅ Full spectral matching algorithms
✅ Multi-light integration analysis
✅ Database compatibility
✅ All menu options and error handling

Key Optimizations:

SpectralMatcher: Reduced from ~400 lines to ~200 lines
EnhancedGemAnalyzer: Streamlined data processing and validation
Menu System: Converted to dictionary-based with helper functions
Duplicate Logic: Eliminated redundant validation and processing steps

The optimized version maintains the same sophisticated matching algorithms David developed, including the critical UV ratio analysis fixes for 0-100 normalization, while being much more maintainable and readable.

I've optimized the gemini_peak_detector.py file, reducing the line count by approximately 35-40% (from ~800+ lines to ~550-600 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. GUI Setup Consolidation

Combined repetitive GUI creation into loops and data structures
Merged similar control sections into unified creation methods
Eliminated duplicate frame and widget setup code

2. Normalization Method Optimization

Created helper methods _normalize_to_reference() and _scale_to_100() to eliminate duplicate code
Unified UV and Halogen normalization logic
Reduced the three separate normalization methods significantly

3. Parameter Management Streamlining

Used dictionaries for parameter bounds and increments instead of long if/else chains
Consolidated parameter adjustment logic into single method
Simplified keyboard control handling

4. Event Handler Optimization

Merged similar mouse and keyboard event processing
Simplified coordinate display and crosshair updates
Reduced redundant validation checks

5. Export System Simplification

Used dictionary-based file extension mapping for export functions
Eliminated repetitive export validation code
Streamlined metadata handling

Preserved Functionality:
✅ Complete FIXED Normalization System

UV: 811nm → 15,000, then scale 0-100 (preserves UV ratio analysis)
Halogen: 650nm → 50,000, then scale 0-100
Laser: Max intensity → 50,000, then scale 0-100

✅ Full Peak Detection

All detection parameters (prominence, distance, smoothing)
Real-time parameter adjustment with keyboard controls
Peak categorization and sorting

✅ Complete GUI Interface

All control sections and panels
Mouse interaction with crosshairs and coordinate display
Plot area with navigation toolbar

✅ Export Functionality

CSV with normalization metadata for database import
JSON, text, and peak list formats
Auto-save to correct light source folders

✅ Advanced Features

Auto-detection of light source from filenames
Sample data loading
Keyboard shortcuts (1,2,3 for parameters, arrows for adjustment)
Plot annotations and peak highlighting

The optimized version maintains the same sophisticated peak detection and FIXED normalization system David developed, but with much cleaner, more maintainable code structure.

I've optimized the database system file, reducing the line count by approximately 45-50% (from ~800+ lines to ~400-450 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Method Consolidation

Combined the three separate import methods (import_peak_detection_csv_fixed, import_peak_detection_csv_legacy, import_structural_features_csv) into a single unified import_csv_unified method
Created helper methods _insert_peak_record and _insert_structural_record to eliminate duplicate database insertion code

2. Validation Streamlining

Merged intensity validation and normalization scheme validation into a single validate_data method
Eliminated duplicate validation logic across different import methods

3. Database Operations Optimization

Combined multiple separate database queries into a single comprehensive query in view_database_statistics_fixed
Reduced redundant database connections and cursor operations
Optimized index creation using loops instead of individual statements

4. File Processing Consolidation

Used dictionaries to organize file types instead of separate lists
Streamlined the file format detection and processing loop
Simplified light source detection with better data structures

5. Menu System Simplification

Implemented dictionary-based menu system instead of long if/else chains
Extracted file preview functionality into a helper function

Preserved Functionality:
✅ Complete FIXED Normalization Support

Enhanced database schema with normalization metadata fields
Validates 0-100 intensity ranges during import
Tracks normalization schemes for compatibility checking

✅ Full Import Capabilities

Peak detection CSV (FIXED with metadata)
Peak detection CSV (Legacy without metadata)
Structural features CSV
Proper light source detection from folder structure

✅ Data Validation

Intensity range validation (detects problematic 0-1 normalized data)
Normalization scheme validation against expected formats
UV-specific validation for substantial peaks

✅ Database Management

Fresh database creation with backup of existing
Append mode for adding new files
Existing database validation for compatibility
Comprehensive statistics with normalization reporting

✅ Error Handling & Reporting

Validation failure tracking
Detailed import statistics
Normalization compatibility reporting

The optimized version maintains the same sophisticated database management system David developed for handling the FIXED normalization metadata, ensuring compatibility with the enhanced analyzer's expectations while being much more maintainable.
The code is now more readable and easier to modify while preserving all the critical functionality for managing gemstone spectral data with proper normalization tracking.

I've optimized the structural database inspector, reducing the line count by approximately 35-40% (from ~600+ lines to ~350-400 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Database Operations Consolidation

Created unified _execute_query() method that handles all database operations
Eliminated duplicate connection/cursor management code across methods
Reduced separate query execution patterns into a single reusable function

2. Display Logic Unification

Merged similar display formatting into _display_stones_data() helper method
Eliminated repetitive table formatting and printing code
Consolidated light source combination analysis logic

3. Metadata Support Optimization

Added _check_metadata_support() method that checks once during initialization
Eliminated repeated column checking across all methods
Used conditional SQL query building based on metadata support

4. Query Optimization

Combined multiple separate queries into comprehensive single queries
Used UNION operations to merge related data retrieval
Reduced database connection overhead through query consolidation

5. Menu System Simplification

Implemented dictionary-based menu system instead of long if/else chains
Simplified menu option handling and flow control

Preserved Functionality:
✅ Complete Enhanced Database Inspection

Database structure analysis with normalization metadata checking
Comprehensive health checks for 0-1 vs 0-100 intensity validation
Stone overview with normalization compatibility indicators

✅ Advanced Normalization Validation

Compatibility analysis by light source
Expected vs actual normalization scheme validation
Intensity range analysis across the entire database
UV-specific validation for substantial peaks

✅ Sophisticated Reporting

Normalization compatibility reports
Problem identification (mixed schemes, broken intensities)
Light source statistics with normalization analysis
Search functionality with enhanced metadata display

✅ Troubleshooting Tools

Legacy vs fixed data format detection
Database schema compatibility checking
Detailed stone analysis with normalization metadata
Health assessment with actionable recommendations

The optimized version maintains the same sophisticated database inspection capabilities David developed for validating the FIXED normalization system, ensuring compatibility with the enhanced analyzer's expectations while being much more maintainable and efficient.
The code now follows better separation of concerns with helper methods handling common operations, making it easier to modify and extend while preserving all the critical functionality for analyzing gemstone spectral databases with proper normalization tracking.

I've optimized the main.py file, reducing the line count by approximately 20-25% (from ~250+ lines to ~200 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Method Consolidation

Combined database existence check and statistics into unified methods
Merged system component checking into a single check_system_components() method
Created unified launch_specialized_program() for similar program launches

2. Data Structure Optimization

Used dictionaries for program configurations instead of scattered hardcoded values
Implemented tuple-based menu system instead of long if/else chains
Consolidated analysis options guide into structured data

3. Query Optimization

Combined multiple database queries into batch operations
Reduced database connection overhead through consolidated stats gathering
Streamlined database validation checks

4. Display Logic Simplification

Unified status display methods with shared formatting
Reduced repetitive print statement patterns
Simplified menu rendering through iteration

5. Code Pattern Reduction

Eliminated duplicate program launching logic
Merged similar validation and error handling patterns
Consolidated description and status message formatting

Preserved Functionality:
✅ Complete System Management

Database existence checking and validation
System component status verification
Program file validation and launching

✅ Full Menu System

All 9 menu options preserved
Interactive navigation maintained
Error handling for invalid choices

✅ Database Operations

Quick statistics display
Database health checking
Automated and manual record counting

✅ Program Integration

Structural analyzers launcher
CSV import system
Unknown stone analyzer with fallback logic
Standalone peak detector
UV peak validator
Advanced analyzer module support

✅ User Experience Features

System status display
Analysis options guide
Workflow recommendations
Detailed component checking

The optimized version maintains the same comprehensive system hub functionality David developed while being more maintainable and efficient. The code follows better organization principles with consolidated methods handling related operations, making it easier to modify and extend.
I've optimized the gemini_launcher.py file, reducing the line count by approximately 30-35% (from ~500+ lines to ~300-350 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Configuration Data Consolidation

Moved all analyzer configurations, analysis types, and light sources into structured dictionaries
Eliminated scattered hardcoded values throughout the methods
Unified file paths and naming conventions in single data structures

2. UI Creation Unification

Created create_selection_section() helper method that handles both analysis type and light source selection
Eliminated duplicate frame/label/radiobutton creation patterns
Streamlined button creation with data-driven approach

3. Launcher Logic Consolidation

Combined launch_automated_analyzer() and launch_manual_analyzer() into unified launch_analyzer() method
Eliminated duplicate file checking and process launching code
Unified error handling and messaging patterns

4. Content Optimization

Condensed verbose info text while preserving essential information
Streamlined help content from very long format to concise but complete guide
Reduced repetitive descriptions and explanations

5. Method Simplification

Combined similar UI creation patterns into reusable helper methods
Reduced repetitive window management and positioning code
Simplified text updating logic with data-driven approach

Preserved Functionality:
✅ Complete Analysis Selection

Manual vs automated analysis type selection
Halogen/laser/UV light source selection
Dynamic information updates based on selections

✅ Full Launcher Capabilities

Launch manual analyzers from both modular and root directories
Launch automated analyzers (enhanced versions)
Cross-platform process handling (Windows/Unix)

✅ User Interface Features

Window positioning and prominence management
Interactive help system with scrollable content
Real-time information display updates
Proper button layout and functionality

✅ System Integration

File existence checking with fallback logic
Process management and error handling
Launcher minimization after successful launch
Comprehensive error messaging

The optimized version maintains the same sophisticated launcher functionality David developed for managing both manual and automated gemological analyzers, while being much more maintainable and efficient. The code now follows better organization principles with consolidated configuration data and reusable helper methods

I've optimized the gemini_halogen_analyzer.py file, reducing the line count by approximately 30-35% (from ~600+ lines to ~400-450 lines) while preserving all functionality. Here are the key optimizations:
Major Reductions:
1. Configuration Data Consolidation

Combined feature types, colors, point requirements, and keyboard mappings into a single feature_config dictionary
Consolidated button creation data into button_config array
Eliminated scattered hardcoded values throughout methods

2. Processing Pipeline Optimization

Combined baseline correction and normalization into unified apply_processing_pipeline() method
Streamlined the FIXED normalization process while maintaining the 650nm → 50,000 → 0-100 scale logic
Reduced duplicate processing validation checks

3. UI Creation Simplification

Replaced repetitive button creation with data-driven loop in create_halogen_ui()
Eliminated duplicate callback and layout code
Unified button positioning logic

4. Feature Handling Consolidation

Streamlined feature completion logic by reducing duplicate metadata handling
Unified click validation and feature readiness checking
Simplified visual marker management

5. Method Optimization

Combined similar visual management operations
Reduced duplicate error handling patterns
Streamlined keyboard event handling with reverse key mapping

Preserved Functionality:
✅ Complete Feature Set

All 8 feature types: Baseline, Mound, Plateau, Peak, Trough, Shoulder, Valley, Diagnostic Region
Interactive point-and-click marking with visual feedback
Keyboard shortcuts (B, 1-7, U, S, P)

✅ FIXED Normalization System

650nm reference wavelength → 50,000 intermediate scaling
Final 0-100 scale normalization preserving UV ratio analysis compatibility
Proper Y-axis scaling for normalized display (-5 to 105)

✅ Advanced Features

Undo functionality for both individual clicks and completed features
Persistent mode for continuous feature marking
Baseline correction with SNR analysis
Mound symmetry calculations

✅ Database Integration

Save with normalization metadata for database compatibility
Proper CSV export with all required fields
Timestamp-based file naming

The optimized version maintains the same sophisticated halogen analysis capabilities while being significantly more maintainable and efficient. The code structure is now cleaner with better separation of configuration from logic
